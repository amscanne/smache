#!/usr/bin/env python

import smache
import sys
import os
import subprocess
import stat
import md5
from pylab import *

def usage(args):
    print "usage: %s <type> <storagepath> <files...>" % (args[0])
    print "where <type> is one of: fixed, fixed-1024, rabin-256, rabin-512, rabin-1024"

def hashname(files):
    digest = md5.new()
    for file in files:
        digest.update(file)
    return digest.hexdigest()

def main(args):
    if len(args) < 4:
        usage(args)
        return

    #
    # Generate a unique (but repeatable) name.
    #
    name = os.path.join(args[2], hashname(args[3:]) + "-" + args[1])
    indexname = name + ".index"
    dbname    = name + ".db"
    gzname    = name + ".tar.gz"

    print name

    #
    # Configure depending on the type.
    #
    spec = smache.Config()
    spec.smache["compression"] = smache.native.SMACHE_LZO
    spec.smache["progress"]    = True
    spec.smache["index"]       = indexname
    spec.backends.append( (smache.backends.getclass("berkeleydb"), {"filename":dbname}) )

    #
    # Set the appropriate blocking parameters.
    # 
    if args[1] == "fixed":
        spec.smache["blockalgo"] = smache.native.SMACHE_FIXED
        spec.smache["blacksize"] = 512
    elif args[1] == "fixed-1024":
        spec.smache["blockalgo"] = smache.native.SMACHE_FIXED
        spec.smache["blacksize"] = 1024
    elif args[1] == "rabin-256":
        spec.smache["blockalgo"] = smache.native.SMACHE_RABIN
        spec.smache["blacksize"] = 256
    elif args[1] == "rabin-512":
        spec.smache["blockalgo"] = smache.native.SMACHE_RABIN
        spec.smache["blacksize"] = 512
    elif args[1] == "rabin-1024":
        spec.smache["blockalgo"] = smache.native.SMACHE_RABIN
        spec.smache["blacksize"] = 1024

    #
    # Create the store object (if necessary).
    #
    store = smache.FileStore(spec)

    #
    # Add all files that are not in the store.
    #
    count = 0
    for file in args[3:]:
        count += store.add(file, False)
    store.index.save()

    #
    # Create the tar.gz if necessary.
    #
    if not(os.path.exists(gzname)):
        count += 1
        gzipargs = ["tar", "-zcvf", gzname]
        gzipargs.extend(args[3:])
        subprocess.call(gzipargs)

    if count > 0:
        print "Done creating files. Re-run to generate graphs."
        sys.exit(0)

    #
    # Re-create the store object.
    #
    store = smache.FileStore(spec)
    stats = store.getstats()

    #
    # Dump the stats for good measure.
    #
    stats.dump()

    #
    # Create the basic graph... boxes with native, gzip and smache breakdown.
    #
    totalsize = stats.totalsize()
    datasizec = stats.compressed_datasize()
    keyover   = stats.keyoverhead()
    hashover  = stats.hashoverhead()
    otherover = (totalsize - datasizec) - (keyover + hashover)

    comparison( name + "-comparison", \
                stats.origsize(), \
                os.path.getsize(gzname), \
                datasizec, keyover, hashover, otherover)

    #
    # Create a graph showing the compression ratio achieved.
    #
    compression(name + "-compression", stats.percent_compressed(), stats.total_compression_ratio())

    #
    # Show a histogram of sharing for the pieces.
    #
    histogram(name + "-datahisto", stats.getdatahashes())
    histogram(name + "-metahisto", stats.getmetahashes())

def comparison( name, originalsize, gzipsize, datasize, keyoverhead, hashoverhead, otheroverhead ):
    clf()

    ds = bar(2.1, datasize, width=0.8, color='green')
    ko = bar(2.1, keyoverhead, bottom=datasize, width=0.8, color='yellow')
    ho = bar(2.1, hashoverhead, bottom=(datasize+keyoverhead), width=0.8, color='purple')
    oo = bar(2.1, otheroverhead, bottom=(datasize+keyoverhead+hashoverhead), width=0.8, color='orange')

    bar(0.1, originalsize, width=0.8, color='red')
    bar(1.1, gzipsize, width=0.8, color='blue')

    legend( (ds, ko, ho, oo), ("Data", "Keys", "Metadata", "DB overhead"), loc="best" )
    ylabel("Bytes")
    xticks( (0.5, 1.5, 2.5), ("original", "gzip", "SMACHE") )
    savefig(name + ".pdf", format="pdf")

def compression( name, percentcompressed, totalcompression ):
    clf()

    #
    # Show a pie chart for the fraction that are not compressed.
    #
    compressed_ratio = (totalcompression - (1.0 - percentcompressed)) / (percentcompressed or 1)
    data = [percentcompressed * compressed_ratio, 1.0 - percentcompressed, percentcompressed * (1.0 - compressed_ratio)]
    pie(data, colors=('green', 'blue', 'white'), labeldistance=0.1)
    legend(("Compressed", "Uncompressed", "Saved"), loc="best")
    savefig(name + ".pdf", format="pdf")

def histogram( name, refs ):
    clf()

    refcounts  = map( lambda x: x[2], refs )
  
    #
    # Ensure that we have at least two different values.
    #
    if len(refcounts) == 0:
        sys.stderr.write("Skipping histogram, no references.\n")
        return
    first = refcounts[0]
    for i in range(1, len(refcounts)):
        if not(refcounts[i] == first):
            break
        elif i == len(refcounts) - 1:
            sys.stderr.write("Skipping histogram, all refcounts are %d.\n" % first)
            return

    #
    # Compute a histogram of the references.
    #
    n, bins, patches = hist( refcounts, log=True, bins=max(refcounts)-min(refcounts), facecolor='green', edgecolor='green', alpha=0.75, label='Chunks' )

    #
    # For each bin, compute how much was saved in that bin.
    # (Do some tricks to get two different axes.)
    #
    # bins.sort()
    # valsu = [0] * len(bins)
    # valsc = [0] * len(bins)
    # totalbins     = sum(n)
    # totalsavingsu = 0
    # totalsavingsc = 0
    # firstbin = bins[0]
    # binwidth = bins[1]-bins[0]
    # for x in refs:
    #      idx = int((x[2] - firstbin)/binwidth)
    #     thesesavingsu = (x[0] - (float(x[0]) / (x[2] or 1)))
    #     totalsavingsu += thesesavingsu
    #     valsu[idx]    += thesesavingsu
    #     thesesavingsc = (x[1] - (float(x[1]) / (x[2] or 1)))
    #     totalsavingsc += thesesavingsc
    #     valsc[idx]    += thesesavingsc
    # valsu = map(lambda x: float(x)*totalbins/(totalsavingsu or 1), valsu)
    # valsc = map(lambda x: float(x)*totalbins/(totalsavingsc or 1), valsc)
    # plot(bins + float(binwidth)/2, valsu, color='blue', alpha=0.75, label='Relative Savings (no compression)', linewidth=3)
    # plot(bins + float(binwidth)/2, valsc, color='red',  alpha=0.75, label='Relative Savings (compression)', linewidth=3)
    # legend( loc="best" )

    ylabel("Chunk Count (log)")
    ylim(min=1)
    xlabel("References")
    savefig(name + ".pdf", format="pdf")

if __name__ == "__main__":
    main(sys.argv)
